<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Feeling Tracker (Cloud)</title>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

<script>
/* ğŸ”´ PASTE YOUR FIREBASE CONFIG HERE */
const firebaseConfig = {
  apiKey: "PASTE_HERE",
  authDomain: "PASTE_HERE",
  projectId: "PASTE_HERE"
};

firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.firestore();
</script>
</head>

<body>
<h2>Feeling Tracker</h2>

<div id="login">
  <input id="email" placeholder="Email"><br>
  <input id="password" type="password" placeholder="Password"><br>
  <button onclick="signup()">Sign Up</button>
  <button onclick="login()">Login</button>
</div>

<div id="app" style="display:none">
  <p>Select Zone:</p>
  <button onclick="save('green')">Green ğŸ˜Š</button>
  <button onclick="save('yellow')">Yellow ğŸ˜</button>
  <button onclick="save('red')">Red ğŸ˜¡</button>
  <button onclick="save('blue')">Blue ğŸ˜´</button>
  <ul id="list"></ul>
</div>

<script>
function autoBreak(zone){
  return (zone === 'red' || zone === 'blue');
}

function save(zone){
  const user = auth.currentUser;
  if(!user) return;

  db.collection("entries").add({
    uid: user.uid,
    zone,
    needBreak: autoBreak(zone),
    time: new Date().toISOString()
  });
}

function load(){
  const user = auth.currentUser;
  db.collection("entries")
    .where("uid","==",user.uid)
    .orderBy("time","desc")
    .onSnapshot(snap=>{
      list.innerHTML="";
      snap.forEach(d=>{
        const e=d.data();
        list.innerHTML+=`<li>${e.time} | ${e.zone} | break: ${e.needBreak}</li>`;
      });
    });
}

auth.onAuthStateChanged(u=>{
  login.style.display = u?"none":"block";
  app.style.display = u?"block":"none";
  if(u) load();
});

function signup(){
  auth.createUserWithEmailAndPassword(email.value,password.value);
}
function login(){
  auth.signInWithEmailAndPassword(email.value,password.value);
}
</script>
</body>
</html>        // Check if we should notify for this user
        const shouldNotify = 
          (user.toLowerCase() === "grant" && notifyGrant) || 
          (user.toLowerCase() === "mrs gibb" && notifyMrsGibb) ||
          (user.toLowerCase() === "mrs. gibb" && notifyMrsGibb) ||
          (user.toLowerCase() === "mrsgibb" && notifyMrsGibb);
        
        if (shouldNotify && Notification.permission === "granted") {
          new Notification(`New entry from ${user}!`, {
            body: `Zone: ${entry.zone.toUpperCase()}${entry.break ? " (ON BREAK)" : ""}`,
            icon: getZoneIcon(entry.zone)
          });
        }
      }
    }
  } catch (error) {
    console.error("Error checking for new entries:", error);
  }
}

// --- Save or update user's feeling ---
window.saveFeeling = async function() {
  const userId = document.getElementById("userId").value.trim();
  const zone = document.getElementById("zone").value;
  const onBreak = document.getElementById("break").checked;

  if (!userId || !zone) { 
    alert("User ID and zone required"); 
    return; 
  }

  try {
    await set(ref(db, `feelings/${userId}`), {
      zone,
      break: onBreak,
      timestamp: Date.now()
    });
    alert("Feeling saved successfully!");
  } catch (error) {
    console.error("Error saving feeling:", error);
    alert("Error saving feeling. Check console for details.");
  }
};

// --- Respond to another user's zone ---
window.respond = async function() {
  const from = document.getElementById("userId").value.trim();
  const target = document.getElementById("targetUser").value.trim();
  const note = document.getElementById("responseNote").value.trim();

  if (!from || !target) { 
    alert("User ID and Target User ID are required"); 
    return; 
  }

  if (from === target) {
    alert("You cannot respond to yourself!");
    return;
  }

  // Just show a local notification - doesn't save to database
  if (Notification.permission === "granted") {
    new Notification(`Test: Response to ${target}`, {
      body: `From ${from}: ${note || "(No message)"}`
    });
    alert(`Notification sent! (This is a local test - only you see it)`);
  } else {
    alert("Please enable notifications first!");
  }
  
  document.getElementById("targetUser").value = "";
  document.getElementById("responseNote").value = "";
};

// --- Export all data to JSON ---
window.exportJSON = async function() {
  try {
    const snapshot = await get(ref(db, "feelings"));
    const data = snapshot.val();
    const json = JSON.stringify(data, null, 2);

    const blob = new Blob([json], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `feelings-${new Date().toISOString().split('T')[0]}.json`;
    a.click();
    URL.revokeObjectURL(url);
  } catch (error) {
    console.error("Error exporting data:", error);
    alert("Error exporting data. Check console for details.");
  }
};

// --- Delete a user's feeling ---
window.deleteFeeling = async function(userId) {
  if (!confirm(`Are you sure you want to delete ${userId}'s feeling?`)) {
    return;
  }

  try {
    await remove(ref(db, `feelings/${userId}`));
    alert(`${userId}'s feeling has been removed.`);
  } catch (error) {
    console.error("Error deleting feeling:", error);
    alert("Error deleting feeling. Check console for details.");
  }
};

// --- Listen to all feelings ---
const feelingsRef = ref(db, "feelings");
onValue(feelingsRef, (snapshot) => {
  const data = snapshot.val() || {};
  renderFeelings(data);

  const currentUserId = document.getElementById("userId").value.trim();

  // Skip notifications on first load
  if (isFirstLoad) {
    lastFeelings = JSON.parse(JSON.stringify(data));
    // Initialize known users with existing users
    for (const user in data) {
      knownUsers.add(user);
    }
    isFirstLoad = false;
    return;
  }

  // Notify for zone updates
  for (const user in data) {
    const entry = data[user];
    
    // Check if this is a new zone update (not on first load)
    if (user !== currentUserId && entry.timestamp) {
      const lastEntry = lastFeelings[user];
      if (!lastEntry || lastEntry.timestamp !== entry.timestamp) {
        if (Notification.permission === "granted") {
          new Notification(`${user} updated their zone`, {
            body: `Zone: ${entry.zone.toUpperCase()}${entry.break ? " (ON BREAK)" : ""}`,
            icon: getZoneIcon(entry.zone)
          });
        }
      }
    }
  }

  // Update last known state
  lastFeelings = JSON.parse(JSON.stringify(data));
}, (error) => {
  console.error("Database error:", error);
  document.getElementById("output").textContent = "Error loading data. Check console.";
});

// --- Helper function to get zone emoji ---
function getZoneIcon(zone) {
  const icons = {
    green: 'ğŸŸ¢',
    blue: 'ğŸ”µ',
    yellow: 'ğŸŸ¡',
    red: 'ğŸ”´'
  };
  return icons[zone] || 'âšª';
}

// --- Render all users and their zones ---
function renderFeelings(data) {
  const output = document.getElementById("output");
  output.innerHTML = "";
  
  if (!data || Object.keys(data).length === 0) { 
    output.textContent = "No data yet. Add your feeling to get started!"; 
    return; 
  }

  const users = Object.keys(data).sort();
  
  for (const user of users) {
    const entry = data[user];
    if (!entry.zone) continue; // Skip invalid entries
    
    const badge = `<span class="badge ${entry.zone}">${entry.zone.toUpperCase()}</span>`;
    const br = entry.break ? " (ON BREAK)" : "";
    const time = new Date(entry.timestamp).toLocaleString();
    const deleteBtn = `<button class="delete-btn" onclick="deleteFeeling('${user}')">ğŸ—‘ï¸ Delete</button>`;
    
    output.innerHTML += `<div class="user-entry"><strong>${user}</strong>: ${badge} ${br} <small>(${time})</small>${deleteBtn}</div>\n`;
  }
}
</script>
</body>
</html>
,    alert("Error saving feeling. Check console for details.");
  }
};

// --- Respond to another user's zone ---
window.respond = async function() {
  const from = document.getElementById("userId").value.trim();
  const target = document.getElementById("targetUser").value.trim();
  const note = document.getElementById("responseNote").value.trim();

  if (!from || !target) { 
    alert("User ID and Target User ID are required"); 
    return; 
  }

  if (from === target) {
    alert("You cannot respond to yourself!");
    return;
  }

  try {
    await push(ref(db, `feelings/${target}/responses`), {
      from,
      note: note || "(No message)",
      timestamp: Date.now()
    });
    alert(`Response sent to ${target}!`);
    document.getElementById("targetUser").value = "";
    document.getElementById("responseNote").value = "";
  } catch (error) {
    console.error("Error sending response:", error);
    alert("Error sending response. Check console for details.");
  }
};

// --- Export all data to JSON ---
window.exportJSON = async function() {
  try {
    const snapshot = await get(ref(db, "feelings"));
    const data = snapshot.val();
    const json = JSON.stringify(data, null, 2);

    const blob = new Blob([json], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `feelings-${new Date().toISOString().split('T')[0]}.json`;
    a.click();
    URL.revokeObjectURL(url);
  } catch (error) {
    console.error("Error exporting data:", error);
    alert("Error exporting data. Check console for details.");
  }
};

// --- Delete a user's feeling ---
window.deleteFeeling = async function(userId) {
  if (!confirm(`Are you sure you want to delete ${userId}'s feeling?`)) {
    return;
  }

  try {
    await remove(ref(db, `feelings/${userId}`));
    alert(`${userId}'s feeling has been removed.`);
  } catch (error) {
    console.error("Error deleting feeling:", error);
    alert("Error deleting feeling. Check console for details.");
  }
};

// --- Listen to all feelings ---
const feelingsRef = ref(db, "feelings");
onValue(feelingsRef, (snapshot) => {
  const data = snapshot.val() || {};
  renderFeelings(data);

  const currentUserId = document.getElementById("userId").value.trim();

  // Skip notifications on first load
  if (isFirstLoad) {
    lastFeelings = JSON.parse(JSON.stringify(data));
    isFirstLoad = false;
    return;
  }

  // Notify for zone updates
  for (const user in data) {
    const entry = data[user];
    
    // Check if this is a new zone update (not on first load)
    if (user !== currentUserId && entry.timestamp) {
      const lastEntry = lastFeelings[user];
      if (!lastEntry || lastEntry.timestamp !== entry.timestamp) {
        if (Notification.permission === "granted") {
          new Notification(`${user} updated their zone`, {
            body: `Zone: ${entry.zone.toUpperCase()}${entry.break ? " (ON BREAK)" : ""}`,
            icon: getZoneIcon(entry.zone)
          });
        }
      }
    }

    // Notify for responses to current user
    if (user === currentUserId && entry.responses) {
      for (const key in entry.responses) {
        const r = entry.responses[key];
        if (!lastResponses[key]) {
          if (Notification.permission === "granted") {
            new Notification(`Response from ${r.from}`, {
              body: r.note || "(No message)"
            });
          }
          lastResponses[key] = true;
        }
      }
    }
  }

  // Update last known state
  lastFeelings = JSON.parse(JSON.stringify(data));
}, (error) => {
  console.error("Database error:", error);
  document.getElementById("output").textContent = "Error loading data. Check console.";
});

// --- Helper function to get zone emoji ---
function getZoneIcon(zone) {
  const icons = {
    green: 'ğŸŸ¢',
    blue: 'ğŸ”µ',
    yellow: 'ğŸŸ¡',
    red: 'ğŸ”´'
  };
  return icons[zone] || 'âšª';
}

// --- Render all users and their zones ---
function renderFeelings(data) {
  const output = document.getElementById("output");
  output.innerHTML = "";
  
  if (!data || Object.keys(data).length === 0) { 
    output.textContent = "No data yet. Add your feeling to get started!"; 
    return; 
  }

  const users = Object.keys(data).sort();
  
  for (const user of users) {
    const entry = data[user];
    if (!entry.zone) continue; // Skip invalid entries
    
    const badge = `<span class="badge ${entry.zone}">${entry.zone.toUpperCase()}</span>`;
    const br = entry.break ? " (ON BREAK)" : "";
    const time = new Date(entry.timestamp).toLocaleString();
    const deleteBtn = `<button class="delete-btn" onclick="deleteFeeling('${user}')">ğŸ—‘ï¸ Delete</button>`;
    
    output.innerHTML += `<div class="user-entry"><strong>${user}</strong>: ${badge} ${br} <small>(${time})</small>${deleteBtn}\n`;
    
    // Show responses if any
    if (entry.responses) {
      for (const key in entry.responses) {
        const r = entry.responses[key];
        const respTime = new Date(r.timestamp).toLocaleString();
        output.innerHTML += `  <span class="response">â†³ Response from <strong>${r.from}</strong>: "${r.note}" <small>(${respTime})</small></span>\n`;
      }
    }
    
    output.innerHTML += "</div>\n";
  }
}
</script>
</body>
</html>

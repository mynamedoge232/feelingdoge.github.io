<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Feeling Tracker with Notifications</title>
<style>
body { font-family: Arial, sans-serif; padding: 20px; max-width: 800px; margin: 0 auto; }
select, input { margin: 5px 0; padding: 8px; width: 100%; max-width: 300px; box-sizing: border-box; }
button { margin: 5px 5px 5px 0; padding: 10px 15px; cursor: pointer; background: #2196F3; color: white; border: none; border-radius: 4px; }
button:hover { background: #1976D2; }
button.delete-btn { background: #F44336; padding: 5px 10px; font-size: 0.85em; margin-left: 10px; }
button.delete-btn:hover { background: #D32F2F; }
pre { background: #f4f4f4; padding: 10px; max-height: 400px; overflow: auto; border-radius: 4px; }
.badge { padding: 3px 8px; border-radius: 5px; color: #fff; margin-right: 5px; font-weight: bold; }
.green { background: #4CAF50; }
.blue { background: #2196F3; }
.yellow { background: #FFEB3B; color: #000; }
.red { background: #F44336; }
.response { margin-left: 20px; font-size: 0.9em; color: #666; }
.user-entry { margin-bottom: 10px; }
hr { margin: 20px 0; border: none; border-top: 1px solid #ddd; }
label { display: block; margin-top: 10px; font-weight: bold; }
</style>
</head>
<body>

<h2>Feeling Tracker</h2>

<label>User ID:</label>
<input id="userId" placeholder="Your name"><br>

<label>Zone:</label>
<select id="zone">
  <option value="">Select zone</option>
  <option value="green">ğŸŸ¢ Green</option>
  <option value="blue">ğŸ”µ Blue</option>
  <option value="yellow">ğŸŸ¡ Yellow</option>
  <option value="red">ğŸ”´ Red</option>
</select><br>

<label><input type="checkbox" id="break" style="width: auto;"> On Break</label><br>

<button onclick="saveFeeling()">Save Feeling</button>
<button onclick="exportJSON()">Export JSON</button>

<hr>
<h3>Respond to Someone</h3>
<label>Target User ID:</label>
<input id="targetUser" placeholder="Target User ID"><br>
<label>Note/Message:</label>
<textarea id="responseNote" placeholder="Optional note or message..." style="width: 100%; max-width: 300px; height: 80px; padding: 8px; box-sizing: border-box; resize: vertical;"></textarea><br>
<button onclick="respond()">Send Response</button>

<hr>
<h3>Current Feelings:</h3>
<pre id="output">Loading...</pre>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getDatabase, ref, set, push, onValue, get, remove } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

// --- Firebase config ---
const firebaseConfig = {
  apiKey: "AIzaSyDz2pQHsSweV2j8vItqOLvqo65rcplzVbc",
  authDomain: "feelingdoge.firebaseapp.com",
  databaseURL: "https://feelingdoge-default-rtdb.firebaseio.com",
  projectId: "feelingdoge",
  storageBucket: "feelingdoge.firebasestorage.app",
  messagingSenderId: "614859671333",
  appId: "1:614859671333:web:cb421bdc7fcf478be33ccc"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

// --- Request notification permission ---
if (Notification.permission !== "granted") {
  Notification.requestPermission();
}

// --- Keep track of known state to prevent duplicate notifications ---
let lastFeelings = {};
let lastResponses = {};
let isFirstLoad = true;

// --- Save or update user's feeling ---
window.saveFeeling = async function() {
  const userId = document.getElementById("userId").value.trim();
  const zone = document.getElementById("zone").value;
  const onBreak = document.getElementById("break").checked;

  if (!userId || !zone) { 
    alert("User ID and zone required"); 
    return; 
  }

  try {
    await set(ref(db, `feelings/${userId}`), {
      zone,
      break: onBreak,
      timestamp: Date.now()
    });
    alert("Feeling saved successfully!");
  } catch (error) {
    console.error("Error saving feeling:", error);
    alert("Error saving feeling. Check console for details.");
  }
};

// --- Respond to another user's zone ---
window.respond = async function() {
  const from = document.getElementById("userId").value.trim();
  const target = document.getElementById("targetUser").value.trim();
  const note = document.getElementById("responseNote").value.trim();

  if (!from || !target) { 
    alert("User ID and Target User ID are required"); 
    return; 
  }

  if (from === target) {
    alert("You cannot respond to yourself!");
    return;
  }

  try {
    await push(ref(db, `feelings/${target}/responses`), {
      from,
      note: note || "(No message)",
      timestamp: Date.now()
    });
    alert(`Response sent to ${target}!`);
    document.getElementById("targetUser").value = "";
    document.getElementById("responseNote").value = "";
  } catch (error) {
    console.error("Error sending response:", error);
    alert("Error sending response. Check console for details.");
  }
};

// --- Export all data to JSON ---
window.exportJSON = async function() {
  try {
    const snapshot = await get(ref(db, "feelings"));
    const data = snapshot.val();
    const json = JSON.stringify(data, null, 2);

    const blob = new Blob([json], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `feelings-${new Date().toISOString().split('T')[0]}.json`;
    a.click();
    URL.revokeObjectURL(url);
  } catch (error) {
    console.error("Error exporting data:", error);
    alert("Error exporting data. Check console for details.");
  }
};

// --- Delete a user's feeling ---
window.deleteFeeling = async function(userId) {
  if (!confirm(`Are you sure you want to delete ${userId}'s feeling?`)) {
    return;
  }

  try {
    await remove(ref(db, `feelings/${userId}`));
    alert(`${userId}'s feeling has been removed.`);
  } catch (error) {
    console.error("Error deleting feeling:", error);
    alert("Error deleting feeling. Check console for details.");
  }
};

// --- Listen to all feelings ---
const feelingsRef = ref(db, "feelings");
onValue(feelingsRef, (snapshot) => {
  const data = snapshot.val() || {};
  renderFeelings(data);

  const currentUserId = document.getElementById("userId").value.trim();

  // Skip notifications on first load
  if (isFirstLoad) {
    lastFeelings = JSON.parse(JSON.stringify(data));
    isFirstLoad = false;
    return;
  }

  // Notify for zone updates
  for (const user in data) {
    const entry = data[user];
    
    // Check if this is a new zone update (not on first load)
    if (user !== currentUserId && entry.timestamp) {
      const lastEntry = lastFeelings[user];
      if (!lastEntry || lastEntry.timestamp !== entry.timestamp) {
        if (Notification.permission === "granted") {
          new Notification(`${user} updated their zone`, {
            body: `Zone: ${entry.zone.toUpperCase()}${entry.break ? " (ON BREAK)" : ""}`,
            icon: getZoneIcon(entry.zone)
          });
        }
      }
    }

    // Notify for responses to current user
    if (user === currentUserId && entry.responses) {
      for (const key in entry.responses) {
        const r = entry.responses[key];
        if (!lastResponses[key]) {
          if (Notification.permission === "granted") {
            new Notification(`Response from ${r.from}`, {
              body: r.note || "(No message)"
            });
          }
          lastResponses[key] = true;
        }
      }
    }
  }

  // Update last known state
  lastFeelings = JSON.parse(JSON.stringify(data));
}, (error) => {
  console.error("Database error:", error);
  document.getElementById("output").textContent = "Error loading data. Check console.";
});

// --- Helper function to get zone emoji ---
function getZoneIcon(zone) {
  const icons = {
    green: 'ğŸŸ¢',
    blue: 'ğŸ”µ',
    yellow: 'ğŸŸ¡',
    red: 'ğŸ”´'
  };
  return icons[zone] || 'âšª';
}

// --- Render all users and their zones ---
function renderFeelings(data) {
  const output = document.getElementById("output");
  output.innerHTML = "";
  
  if (!data || Object.keys(data).length === 0) { 
    output.textContent = "No data yet. Add your feeling to get started!"; 
    return; 
  }

  const users = Object.keys(data).sort();
  
  for (const user of users) {
    const entry = data[user];
    if (!entry.zone) continue; // Skip invalid entries
    
    const badge = `<span class="badge ${entry.zone}">${entry.zone.toUpperCase()}</span>`;
    const br = entry.break ? " (ON BREAK)" : "";
    const time = new Date(entry.timestamp).toLocaleString();
    const deleteBtn = `<button class="delete-btn" onclick="deleteFeeling('${user}')">ğŸ—‘ï¸ Delete</button>`;
    
    output.innerHTML += `<div class="user-entry"><strong>${user}</strong>: ${badge} ${br} <small>(${time})</small>${deleteBtn}\n`;
    
    // Show responses if any
    if (entry.responses) {
      for (const key in entry.responses) {
        const r = entry.responses[key];
        const respTime = new Date(r.timestamp).toLocaleString();
        output.innerHTML += `  <span class="response">â†³ Response from <strong>${r.from}</strong>: "${r.note}" <small>(${respTime})</small></span>\n`;
      }
    }
    
    output.innerHTML += "</div>\n";
  }
}
</script>
</body>
</html>
